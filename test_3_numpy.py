# -*- coding: utf-8 -*-
"""test 3 numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/149eeYznw7iJJkJEQoA1PJyt2KRtCJBa1
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# 1. Create a NumPy array 'arr' of integers from 0 to 5 and print its data type.
l = [1, 2, 3, 4, 5, 6]
arr = np.array(l)
print(arr)
print(type(arr))

#2. Given a NumPy array 'arr', check if its data type is float64.
arr = np.array([1.5, 2.6, 3.7])

print(arr.dtype)

# 3. Create a NumPy array 'arr' with a data type of complex128 containing three complex numbers.

arr = np.array([1+2j, 3+4j, 5+6j], dtype=np.complex128)

print(arr)

# 4. Convert an existing NumPy array 'arr' of integers to float32 data type.

arr = np.array([1, 2, 3, 4, 5])

new_arr = arr.astype(np.float32)

print(new_arr)

# 5. Given a NumPy array 'arr' with float64 data type, convert it to float32 to reduce decimal precision.

arr = np.array([1.5, 2.6, 3.7], dtype=np.float64)

new_arr = arr.astype(np.float32)

print(new_arr)

# 6. Write a function array_attributes that takes a NumPy array as input and returns its shape, size, and data type.
def array_attributes(arr):
    shape = arr.shape
    size = arr.size
    dtype = arr.dtype
    return shape, size, dtype
arr = np.array([[1, 2, 3], [4, 5, 6]])

shape, size, dtype = array_attributes(arr)

print(f"Shape: {shape}")
print(f"Size: {size}")
print(f"Data Type: {dtype}")

# 7. Create a function array_dimension that takes a NumPy array as input and returns its dimensionality

def array_dimension(arr):
    return arr.ndim

arr1 = np.array([1, 2, 3])
arr2 = np.array([[1, 2, 3], [4, 5, 6]])
arr3 = np.array([[[1], [2]], [[3], [4]]])


dim1 = array_dimension(arr1)
dim2 = array_dimension(arr2)
dim3 = array_dimension(arr3)

print(f"Dimensionality of arr1: {dim1}")
print(f"Dimensionality of arr2: {dim2}")
print(f"Dimensionality of arr3: {dim3}")

# 8. Design a function item_size_info that takes a NumPy array as input and returns the item size and the total
# size in bytes.

def item_size_info(arr):
    item_size = arr.itemsize
    total_size = arr.nbytes
    return item_size, total_size

arr = np.array([1, 2, 3])

item_size, total_size = item_size_info(arr)

print(f"Item Size: {item_size} bytes")
print(f"Total Size: {total_size} bytes")

# 9.  Create a function array_strides that takes a NumPy array as input and returns the strides of the array

def array_strides(arr):
    strides = arr.strides
    return strides

arr = np.array([[1, 2, 3], [4, 5, 6]])

strides = array_strides(arr)

print(f"Strides: {strides}")

# 10. Design a function shape_stride_relationship that takes a NumPy array as input and returns the shape
# and strides of the array.

def shape_stride_relationship(arr):
    shape = arr.shape
    strides = arr.strides
    return shape, strides

arr = np.array([[1, 2, 3], [4, 5, 6]])

shape, strides = shape_stride_relationship(arr)

print(f"Shape: {shape}")
print(f"Strides: {strides}")

# 11. Create a function `create_zeros_array` that takes an integer `n` as input and returns a NumPy array of
# zeros with `n` elements.

def create_zeros_array(n):
    zeros_array = np.zeros(n)
    return zeros_array

n = 5
zeros_array = create_zeros_array(n)

print(zeros_array)

# 12. Write a function `create_ones_matrix` that takes integers `rows` and `cols` as inputs and generates a 2D
# NumPy array filled with ones of size `rows x cols`.

def create_ones_matrix(rows, cols):
    ones_matrix = np.ones((rows, cols))
    return ones_matrix

rows = 3
cols = 4

ones_matrix = create_ones_matrix(rows, cols)

print(ones_matrix)

# 13. Write a function `generate_range_array` that takes three integers start, stop, and step as arguments and
# creates a NumPy array with a range starting from `start`, ending at stop (exclusive), and with the specified `step`.

def generate_range_array(start, stop, step):
    range_array = np.arange(start, stop, step)
    return range_array

start = 1
stop = 10
step = 2

range_array = generate_range_array(start, stop, step)

print(range_array)

# 14. 14. Design a function `generate_linear_space` that takes two floats `start`, `stop`, and an integer `num` as
# arguments and generates a NumPy array with num equally spaced values between `start` and `stop`
# (inclusive).

def generate_linear_space(start, stop, num):
    linear_space = np.linspace(start, stop, num)
    return linear_space

start = 1.0
stop = 10.0
num = 5

linear_space = generate_linear_space(start, stop, num)

print(linear_space)

# 15. Create a function `create_identity_matrix` that takes an integer `n` as input and generates a square
# identity matrix of size `n x n` using `numpy.eye`.

def create_identity_matrix(n):
    identity_matrix = np.eye(n)
    return identity_matrix

n = 3

identity_matrix = create_identity_matrix(n)

print(identity_matrix)

# 16. Write a function that takes a Python list and converts it into a NumPy array.

def convert_list_to_array(input_list):
    array = np.array(input_list)
    return array

input_list = [1, 2, 3, 4, 5]

array = convert_list_to_array(input_list)

print(array)

#  17. Create a NumPy array and demonstrate the use of `numpy.view` to create a new array object with the
# same data.

arr = np.array([1, 2, 3, 4, 5])
print("arr1:", arr)


view_array = arr.view()
print("View array:", view_array)


arr[0] = 10
print("Modified arr:", arr)
print("View array after modifying the arr:", view_array)

#  19. Create two NumPy arrays with different shapes and concatenate them horizontally using `numpy.concatenate`.

np1 = np.array([[1, 2], [3, 4]])
np2 = np.array([[5, 6], [7, 8]])

np3 = np.concatenate((np1, np2), axis=1)

print(np3)

# 20. Write a function that vertically stacks multiple NumPy arrays given as a list

def vertical_stack(arrays):
    return np.vstack(arrays)

arrays = [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9])]

stacked_array = vertical_stack(arrays)

print(stacked_array)

# 21. Write a Python function using NumPy to create an array of integers within a specified range (inclusive)
# with a given step size.

def create_integer_array(start, stop, step):
    return np.arange(start, stop + 1, step)

start = 1
stop = 10
step = 2

integer_array = create_integer_array(start, stop, step)

print(integer_array)

# 22. Write a Python function using NumPy to generate an array of 10 equally spaced values between 0 and 1
# (inclusive).

def generate_equally_spaced_array():
    return np.linspace(0, 1, 10)

equally_spaced_array = generate_equally_spaced_array()

print(equally_spaced_array)

# 23. Write a Python function using NumPy to create an array of 5 logarithmically spaced values between 1 and
# 1000 (inclusive).

def create_logarithmically_spaced_array():
    return np.logspace(1, 1000, 5)

logarithmically_spaced_array = create_logarithmically_spaced_array()

print(logarithmically_spaced_array)

# 25. Write a function that takes a Pandas DataFrame and replaces all negative values in a specific column
# with zeros. Use NumPy operations within the Pandas DataFrame.

def replace_negative_values(df, column_name):
    df[column_name] = np.where(df[column_name] < 0, 0, df[column_name])
    return df
data = {'A': [1, -2, 3, -4, 5], 'B': [-1, 2, -3, 4, -5]}
df = pd.DataFrame(data)
df = replace_negative_values(df, 'A',)
df = replace_negative_values(df, 'B',)
print(df)

# 26. Access the 3rd element from the given NumPy array.

arr = np.array([10, 20, 30, 40, 50])

arr[2]

# 27. Retrieve the element at index (1, 2) from the 2D NumPy array.

arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

element = arr_2d[1, 2]

print(element)

# 28. Using boolean indexing, extract elements greater than 5 from the given NumPy array.

arr = np.array([3, 8, 2, 10, 5, 7])

aked_elements = arr[arr > 5]
print(aked_elements)

# 29. Perform basic slicing to extract elements from index 2 to 5 (inclusive) from the given NumPy array.

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
elements = arr[2:6]
print(elements)

# 30 Slice the 2D NumPy array to extract the sub-array `[[2, 3], [5, 6]]` from the given array.

arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

sub_arr = arr_2d[0:2, 1:3]
print(sub_arr)

# Write a NumPy function to extract elements in specific order from a given 2D array based on indices
# provided in another array
def extract_elements(arr, indices):
  assert indices.shape[1] == 2, "Indices should have shape (N, 2)"
  extracted_elements = arr[indices[:, 0], indices[:, 1]]
  return extracted_elements

arr = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
indices = np.array([[0, 1], [2, 2], [1, 0]])

extracted_elements = extract_elements(arr, indices)
print(extracted_elements)

# 32. Create a NumPy function that filters elements greater than a threshold from a given 1D array using
# boolean indexing.

arr = np.array([1, 5, 6, 3, 4, 10])
aked_elements = arr[arr > 5]
print(aked_elements)

# 33. Develop a NumPy function that extracts specific elements from a 3D array using indices provided in three
# separate arrays for each dimension.

def extract_elements_3d(arr, x_indices, y_indices, z_indices):
    extracted_elements = arr[x_indices, y_indices, z_indices]
    return extracted_elements
arr = np.array([[[10, 20, 30], [40, 50, 60]],
              [[70, 80, 90], [100, 110, 120]]])

x_indices = np.array([0, 1, 1])
y_indices = np.array([1, 0, 1])
z_indices = np.array([2, 1, 0])

extracted_elements = extract_elements_3d(arr, x_indices, y_indices, z_indices)
print("Extracted elements:", extracted_elements)

# 34. Write a NumPy function that returns elements from an array where both two conditions are satisfied
# using boolean indexing.

def filter_elements(arr, condition1, condition2):
    condition_met = (arr > condition1[1]) & (arr < condition2[1])
    filtered_elements = arr[condition_met]
    return filtered_elements

arr = np.array([1, 3, 5, 7, 9, 11, 13, 15])
condition1 = ('gt', 4)
condition2 = ('lt', 12)

filtered_elements = filter_elements(arr, condition1, condition2)
print(filtered_elements)

# 35. Create a NumPy function that extracts elements from a 2D array using row and column indices provided in separate arrays.

def extract_elements(arr, row_indices, col_indices):
  row_indices = np.array(row_indices)
  col_indices = np.array(col_indices)
  extracted_elements = arr[row_indices, col_indices]
  return extracted_elements


arr = np.array([[10, 20, 30],
                [40, 50, 60],
                [70, 80, 90]])
row_indices = [0, 1, 2]
col_indices = [2, 1, 0]

extracted_elements = extract_elements(arr, row_indices, col_indices)
print(extracted_elements)

# 36. Given an array arr of shape (3, 3), add a scalar value of 5 to each element using NumPy broadcasting.

arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

add_scaler = arr + 5

print(add_scaler)

# 37. Consider two arrays arr1 of shape (1, 3) and arr2 of shape (3, 4). Multiply each row of arr2 by the
# corresponding element in arr1 using NumPy broadcasting.
arr1 = np.array([[1, 2, 3]])
arr2 = np.array([[1,2,3,4],
                 [4,5,6,7],
                 [7,8,9,10]])

Multiplication_of_arr = arr1.T * arr2

print(Multiplication_of_arr)

# 38. Given a 1D array arr1 of shape (1, 4) and a 2D array arr2 of shape (4, 3), add arr1 to each row of arr2 using
# NumPy broadcasting.


arr1 = np.array([1, 2, 3, 4]).reshape(4, 1)
arr2 = np.array([[1, 3, 4],
                 [3, 5, 6],
                 [5, 3, 6],
                 [5, 3, 3]])


add_arr = arr1 + arr2
print(add_arr)

# 39. Consider two arrays arr1 of shape (3, 1) and arr2 of shape (1, 3). Add these arrays using NumPy
# broadcasting.

arr1 = np.array([[1],
                 [2],
                 [3]])
arr2 = np.array([[1, 2, 3]])

add_arr = arr1 + arr2
print(add_arr)

# 40. Given arrays arr1 of shape (2, 3) and arr2 of shape (2, 2), perform multiplication using NumPy
# broadcasting. Handle the shape incompatibility.

arr1 = np.array([[1, 2, 3],
                 [4, 5, 6]])
arr2 = np.array([[1, 2],
                 [3, 4]])

new_arr2 = arr2[:, :, np.newaxis]
Multiplication_of_arr = arr1 * new_arr2
print(Multiplication_of_arr)

# . 41.Calculate column wise mean for the given array:

arr = np.array([[1, 2, 3], [4, 5, 6]])

arr_mean = np.mean(arr, axis = 0)
print(arr_mean)

# 42. Find maximum value in each row of the given array:
arr = np.array([[1, 2, 3], [4, 5, 6]])

arr_max = np.max(arr, axis = 1)
print(arr_max)

# 43 . For the given array, find indices of maximum value in each column.

arr = np.array([[1, 2, 3], [4, 5, 6]])

arr_max = np.argmax(arr, axis = 0)
print(arr_max)

# 44.  For the given array, apply custom function to calculate moving sum along rows.

arr = np.array([[1, 2, 3], [4, 5, 6]])

def moving_sum(arr):
  result = np.zeros_like(arr)
  for i in range(arr.shape[0]):
    for j in range(arr.shape[1]):
      result[i, j] = np.sum(arr[i, :j+1])
  return result

moving_sum = moving_sum(arr)
print(moving_sum)

# 45.   In the given array, check if all elements in each column are even.

arr = np.array([[2, 4, 6], [3, 5, 7]])
even_check = np.all(arr % 2 == 0, axis=0)
print(even_check)

# 46. Given a NumPy array arr, reshape it into a matrix of dimensions `m` rows and `n` columns. Return the
# reshaped matrix.

original_array = np.array([1, 2, 3, 4, 5, 6])
m = 2
n = 3
reshaped_matrix = original_array.reshape(m, n)
print(reshaped_matrix)

# 47. Create a function that takes a matrix as input and returns the flattened array.

input_matrix = np.array([[1, 2, 3], [4, 5, 6]])

def flatten_matrix(matrix):
  return matrix.flatten()
flattened_array = flatten_matrix(input_matrix)
print(flattened_array)

# 48. Write a function that concatenates two given arrays along a specified axis.

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])

def concatenate_arrays(array1, array2, axis):
  return np.concatenate((array1, array2), axis=axis)

concatenated_array = concatenate_arrays(array1, array2, axis=0)
print(concatenated_array)

# 49. Create a function that splits an array into multiple sub-arrays along a specified axis

original_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

def split_array(arr, num_splits, axis):
  return np.array_split(arr, num_splits, axis)

original_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

split_result = split_array(original_array, 3, 0)

for i, sub_array in enumerate(split_result):
    print(f"Sub-array {i}:\n{sub_array}\n")
split_result = split_array(original_array, 3, 1)

for i, sub_array in enumerate(split_result):
    print(f"Sub-array {i}:\n{sub_array}\n")

# 50. Write a function that inserts and then deletes elements from a given array at specified indices.

original_array = np.array([1, 2, 3, 4, 5])
indices_to_insert = [2, 4]
values_to_insert = [10, 11]
indices_to_delete = [1, 3]

import numpy as np

def insert_and_delete_elements(arr, indices_to_insert, values_to_insert, indices_to_delete):
    arr_with_inserts = np.insert(arr, indices_to_insert, values_to_insert)


    adjusted_indices_to_delete = np.array(indices_to_delete) + np.searchsorted(indices_to_insert, indices_to_delete)


    modified_arr = np.delete(arr_with_inserts, adjusted_indices_to_delete)

    return modified_arr


original_array = np.array([1, 2, 3, 4, 5])
indices_to_insert = [2, 4]
values_to_insert = [10, 11]
indices_to_delete = [1, 3]


result_array = insert_and_delete_elements(original_array, indices_to_insert, values_to_insert, indices_to_delete)


print("Original array:", original_array)
print("Array after insertion and deletion:", result_array)

# 51. Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 10.
# Perform element-wise addition between `arr1` and `arr2`.

arr1 = [1,3,2,4,5,6,3,2,7,4]
arr2 = [1,2,3,4,5,6,7,8,9,10]
arr1 = np.array(arr1)
arr2 = np.array(arr2)
arr3 = arr1 + arr2
print(arr3)

# 52. Generate a NumPy array `arr1` with sequential integers from 10 to 1 and another array `arr2` with integers
# from 1 to 10. Subtract `arr2` from `arr1` element-wise.

arr1 = np.arange(10, 0, -1)
arr2 = np.arange(1, 11)
arr3 = arr1 - arr2
print(arr3)

# 53. Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 5.
# Perform element-wise multiplication between `arr1` and `arr2`.


np.random.seed(0)

arr1 = np.random.randint(0, 11, size=5)

arr2 = np.array([1, 2, 3, 4, 5])

result = arr1 * arr2

print("arr1:", arr1)
print("arr2:", arr2)
print("Element-wise multiplication result:", result)

# 54. Generate a NumPy array `arr1` with even integers from 2 to 10 and another array `arr2` with integers from 1
# to 5. Perform element-wise division of `arr1` by `arr2`.

arr1 = np.arange(2, 11, 2)
arr2 = np.array([1, 2, 3, 4, 5])
result = arr1 / arr2
print("arr1:", arr1)
print("arr2:", arr2)
print("Element-wise division result:", result)

#55. Create a NumPy array `arr1` with integers from 1 to 5 and another array `arr2` with the same numbers
# reversed. Calculate the exponentiation of `arr1` raised to the power of `arr2` element-wise.

arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([5, 4, 3, 2, 1])
result = arr1 ** arr2
print(result)

# 56. Write a function that counts the occurrences of a specific substring within a NumPy array of strings

arr = np.array(['hello', 'world', 'hello', 'numpy', 'hello'])
substring = 'hello'

def count_substring_occurrences(arr, substring):
    count = 0
    for element in arr:
        if substring in element:
            count += 1
    return count

count = count_substring_occurrences(arr, substring)
print(f"The substring '{substring}' appears {count} times in the array.")

# 57. Write a function that extracts uppercase characters from a NumPy array of strings. arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])

arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])

def extract_uppercase(arr):
    uppercase_chars = []
    for string in arr:
        for char in string:
            if char.isupper():
                uppercase_chars.append(char)
    return uppercase_chars

arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])
result = extract_uppercase(arr)
print(result)

# 58. Write a function that replaces occurrences of a substring in a NumPy array of strings with a new string.

arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
old_substring = 'apple'
new_substring = 'orange'

def replace_substring(arr, old_substring, new_substring):
    new_arr = []
    for string in arr:
        new_string = string.replace(old_substring, new_substring)
        new_arr.append(new_string)
    return np.array(new_arr)

    arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
result = replace_substring(arr, old_substring, new_substring)
print(result)

# 59. Write a function that concatenates strings in a NumPy array element-wise.

arr1 = np.array(['Hello', 'World'])
arr2 = np.array(['Open', 'AI'])

def concatenate_strings(arr1, arr2):
    concatenated_arr = np.char.add(arr1, arr2)
    return concatenated_arr

arr1 = np.array(['Hello', 'World'])
arr2 = np.array(['Open', 'AI'])
result = concatenate_strings(arr1, arr2)
print(result)

# 60. Write a function that finds the length of the longest string in a NumPy array.

arr = np.array(['apple', 'banana', 'grape', 'pineapple'])

def find_longest_string(arr):
    longest_string = ''
    for string in arr:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string

arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
result = find_longest_string(arr)
print(result)

# 61. Create a dataset of 100 random integers between 1 and 1000. Compute the mean, median, variance, and
# standard deviation of the dataset using NumPy's functions.

np.random.seed(0)
arr = np.random.randint(1, 1001, size=100)

mean = np.mean(arr)
median = np.median(arr)
variance = np.var(arr)
std_dev = np.std(arr)

print("Mean:", mean)
print("Median:", median)
print("Variance:", variance)
print("Standard Deviation:", std_dev)

# 62. Generate an array of 50 random numbers between 1 and 100. Find the 25th and 75th percentiles of the dataset.

np.random.seed(0)
arr = np.random.randint(1, 101, size=50)

percentile_25 = np.percentile(arr, 25)
percentile_75 = np.percentile(arr, 75)

print("25th Percentile:", percentile_25)
print("75th Percentile:", percentile_75)

# 63. Create two arrays representing two sets of variables. Compute the correlation coefficient between these
# arrays using NumPy's `corrcoef` function.

arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([2, 4, 6, 8, 10])

correlation_coefficient = np.corrcoef(arr1, arr2)[0, 1]

print("Correlation Coefficient:", correlation_coefficient)

# 64. Create two matrices and perform matrix multiplication using NumPy's `dot` function.

arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

result = np.dot(arr1, arr2)

print("Matrix Multiplication Result:")
print(result)

# 65. Create an array of 50 integers between 10 and 1000. Calculate the 10th, 50th (median), and 90th
# percentiles along with the first and third quartiles

arr = np.random.randint(10, 1001, size=50)

percentile_10th = np.percentile(arr, 10)
median = np.percentile(arr, 50)
percentile_90th = np.percentile(arr, 90)

first_quartile = np.percentile(arr, 25)
third_quartile = np.percentile(arr, 75)

print("Array:", arr)
print("10th percentile:", percentile_10th)
print("Median (50th percentile):", median)
print("90th percentile:", percentile_90th)
print("First quartile (25th percentile):", first_quartile)
print("Third quartile (75th percentile):", third_quartile)

# 66. Create a NumPy array of integers and find the index of a specific element


arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

element = 50
index = np.where(arr == element)[0]

if index.size > 0:
    print(f"The index of the element {element} is: {index[0]}")
else:
    print(f"The element {element} is not in the array.")

# 67. Generate a random NumPy array and sort it in ascending order

arr = np.random.randint(1, 101, size=10)

sorted_arr = np.sort(arr)

print("Original Array:", arr)
print("Sorted Array:", sorted_arr)

# 68. Filter elements >20  in the given NumPy array.

arr = np.array([12, 25, 6, 42, 8, 30])
filtered_arr = arr[arr > 20]
print(filtered_arr)

#  69.Filter elements which are divisible by 3 from a given NumPy array.
arr = np.array([1, 5, 8, 12, 15])
filtered_arr = arr[arr % 3 == 0]
print(filtered_arr)

#70. Filter elements which are ≥ 20 and ≤ 40 from a given NumPy array.
arr = np.array([10, 20, 30, 40, 50])

filtered_arr = arr[(arr >= 20) & (arr <= 40)]
print(filtered_arr)

# 71. For the given NumPy array, check its byte order using the `dtype` attribute byteorder.
arr = np.array([1, 2, 3])
byte_order = arr.dtype.byteorder
print(byte_order)

#72. For the given NumPy array, perform byte swapping in place using `byteswap()`.

arr = np.array([1, 2, 3], dtype=np.int32)
arr.byteswap(True)
print("Byte-swapped array:", arr)

# 73. For the given NumPy array, swap its byte order without modifying the original array using
# `newbyteorder()`.

arr = np.array([1, 2, 3], dtype=np.int32)

swapped_arr = arr.newbyteorder()
print("Original array:", arr)
print("Byte-swapped array:", swapped_arr)

# 74.For the given NumPy array and swap its byte order conditionally based on system endianness using
# `newbyteorder()`.

arr = np.array([1, 2, 3], dtype=np.int32)

system_byte_order = np.dtype('<i4').byteorder
current_byte_order = arr.dtype.byteorder

if (system_byte_order == '<' and current_byte_order == '>') or (system_byte_order == '>' and current_byte_order == '<'):
    swapped_arr = arr.newbyteorder()
else:
    swapped_arr = arr


print("Original array:", arr)
print("Byte-swapped array (if necessary):", swapped_arr)

# 75. For the given NumPy array, check if byte swapping is necessary for the current system using `dtype`
# attribute `byteorder`.

arr = np.array([1, 2, 3], dtype=np.int32)

system_byte_order = '<' if np.little_endian else '>'

array_byte_order = arr.dtype.byteorder

if (system_byte_order == '<' and array_byte_order == '>') or (system_byte_order == '>' and array_byte_order == '<'):
    print("Byte swapping is necessary.")
else:
    print("Byte swapping is not necessary.")

# 76. Create a NumPy array `arr1` with values from 1 to 10. Create a copy of `arr1` named `copy_arr` and modify
# an element in `copy_arr`. Check if modifying `copy_arr` affects `arr1`.

arr1 = np.arange(1, 11)
copy_arr = arr1.copy()
copy_arr[0] = 99
print("Original array (arr1):", arr1)
print("Modified copy (copy_arr):", copy_arr)

# 77. Create a 2D NumPy array `matrix` of shape (3, 3) with random integers. Extract a slice `view_slice` from
# the matrix. Modify an element in `view_slice` and observe if it changes the original `matrix`.

matrix = np.random.randint(0, 10, (3, 3))
print("Original matrix:\n", matrix)

view_slice = matrix[:2, :2]
print("Extracted slice:\n", view_slice)

view_slice[0, 0] = 99
print("Modified slice:\n", view_slice)

print("Modified matrix:\n", matrix)

# 78. Create a NumPy array `array_a` of shape (4, 3) with sequential integers from 1 to 12. Extract a slice
# `view_b` from `array_a` and broadcast the addition of 5 to view_b. Check if it alters the original `array_a`.


array_a = np.arange(1, 13).reshape(4, 3)
print("Original array_a:\n", array_a)

view_b = array_a[:2, :]
print("Extracted view_b:\n", view_b)

view_b += 5
print("Modified view_b after broadcasting addition:\n", view_b)

print("Modified array_a:\n", array_a)

# 79. Create a NumPy array `orig_array` of shape (2, 4) with values from 1 to 8. Create a reshaped view
# `reshaped_view` of shape (4, 2) from orig_array. Modify an element in `reshaped_view` and check if it
# reflects changes in the original `orig_array`.

orig_array = np.arange(1, 9).reshape(2, 4)
print("Original array:\n", orig_array)

reshaped_view = orig_array.reshape(4, 2)
print("Reshaped view:\n", reshaped_view)

reshaped_view[0, 0] = 99
print("Modified reshaped view:\n", reshaped_view)

print("Modified original array:\n", orig_array)

# 80. Create a NumPy array `data` of shape (3, 4) with random integers. Extract a copy `data_copy` of
# elements greater than 5. Modify an element in `data_copy` and verify if it affects the original `data`.

data = np.random.randint(0, 10, (3, 4))
print("Original data:\n", data)

data_copy = data[data > 5].copy()
print("Data copy (elements > 5):\n", data_copy)

if data_copy.size > 0:
    data_copy[0] = 99
print("Modified data copy:\n", data_copy)

print("Original data after modification in copy:\n", data)

# 81. Create two matrices A and B of identical shape containing integers and perform addition and subtraction
# operations between them.

A = np.random.randint(0, 10, (3, 3))
B = np.random.randint(0, 10, (3, 3))

print("Matrix A:\n", A)
print("Matrix B:\n", B)

C_add = A + B
print("A + B:\n", C_add)

C_subtract = A - B
print("A - B:\n", C_subtract)

# 82. Generate two matrices `C` (3x2) and `D` (2x4) and perform matrix multiplication.

C = np.random.randint(0, 10, (3, 2))
print("Matrix C:\n", C)

D = np.random.randint(0, 10, (2, 4))
print("Matrix D:\n", D)

result = np.matmul(C, D)
print("Result of C @ D:\n", result)

# 83. Create a matrix `E` and find its transpose.

E = np.random.randint(0, 10, (3, 4))
print("Matrix E:\n", E)

E_transpose = E.T
print("Transpose of E:\n", E_transpose)

# 84. Generate a square matrix `F` and compute its determinant.

F = np.random.randint(0, 10, (3, 3))
print("Matrix F:\n", F)

det_F = np.linalg.det(F)
print("Determinant of F:", det_F)

# 85. Create a square matrix `G` and find its inverse.

G = np.random.randint(1, 10, (3, 3))
print("Matrix G:\n", G)

try:
    G_inverse = np.linalg.inv(G)
    print("Inverse of G:\n", G_inverse)
except np.linalg.LinAlgError:
    print("Matrix G is singular and does not have an inverse.")